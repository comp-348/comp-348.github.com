<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-11-10 Tue 21:29 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Memory allocation and structs with hashmaps</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Philip Dumaresq">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://comp-348.github.io/assets/org.css" />
<link id="theme" rel="stylesheet" type="text/css" href="assets/dark-theme.css" />
<link rel="stylesheet" type="text/css" href="assets/org.css" />
<script src="assets/toggle.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Memory allocation and structs with hashmaps</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4a42f4a">Problem</a>
<ul>
<li><a href="#org4d0d62c">getHash</a></li>
<li><a href="#org9b9a90f">setHash</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="org-center">
<div class="header" id="org0f8eeff">
<p>
<a href="index.html">Back</a>
</p>

</div>
</div>

<div class="toggle" id="org31379ac">

<div id="orgea78dc3" class="figure">
<p><img src="assets/toggle-theme.png" alt="toggle-theme.png">
</p>
</div>

</div>

<div id="outline-container-org4a42f4a" class="outline-2">
<h2 id="org4a42f4a">Problem</h2>
<div class="outline-text-2" id="text-org4a42f4a">
<p>
The first thing we need do is decide how we&rsquo;re going to model the data for our map. This isn&rsquo;t going
to be a <i>true</i> hashmap because we&rsquo;re not going to actually hash the keys at all. We&rsquo;re just going to
use a struct called <code>Pair</code> that contains the key/value pairs, like so:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">struct</span> <span class="org-type">Pair</span> {
  <span class="org-type">char</span> *<span class="org-variable-name">key</span>;
  <span class="org-type">int</span> <span class="org-variable-name">value</span>;
};
</pre>
</div>

<p>
We&rsquo;re just going to store integers as our values, although we could store anything here. Our map
itself is just going to be an array of <code>Pair</code> structs.
</p>
</div>

<div id="outline-container-org4d0d62c" class="outline-3">
<h3 id="org4d0d62c">getHash</h3>
<div class="outline-text-3" id="text-org4d0d62c">
<p>
Now that we&rsquo;ve determined how we&rsquo;re going to store our data, your exercise is to implement 2
functions. The first one is going to be called <code>getHash</code>. It will take 3 arguments, the first one will
be our array that the map is stored in, and the second will be it&rsquo;s size. The final argument is the
key you&rsquo;re searching for.
</p>

<p>
The function can be used as below:
</p>
<div class="org-src-container">
<pre class="src src-c"><span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">len</span> = <span class="org-highlight-numbers-number">2</span>;
  <span class="org-keyword">struct</span> <span class="org-type">Pair</span> <span class="org-variable-name">hashmap</span> = malloc(<span class="org-keyword">sizeof</span>(<span class="org-keyword">struct</span> <span class="org-type">Pair</span>) * len);
  hashmap[<span class="org-highlight-numbers-number">0</span>].key = <span class="org-string">"Key 1"</span>;
  hashmap[<span class="org-highlight-numbers-number">0</span>].value = <span class="org-highlight-numbers-number">1</span>;
  hashmap[<span class="org-highlight-numbers-number">1</span>].key = <span class="org-string">"Key 2"</span>;
  hashmap[<span class="org-highlight-numbers-number">1</span>].value = <span class="org-highlight-numbers-number">2</span>;

  printf(<span class="org-string">"%d"</span>, getHash(hashmap, len, <span class="org-string">"Key 1"</span>)); <span class="org-comment-delimiter">// </span><span class="org-comment">1</span>

  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
}
</pre>
</div>

<button class="toggle-spoiler">Show answer</button>
<div class="org-src-container">
<pre class="src src-c"><span class="org-type">int</span> <span class="org-function-name">getHash</span>(<span class="org-keyword">struct</span> <span class="org-type">Pair</span> *<span class="org-variable-name">map</span>, <span class="org-type">int</span> <span class="org-variable-name">size</span>, <span class="org-type">char</span> *<span class="org-variable-name">key</span>) {
  <span class="org-keyword">for</span> (<span class="org-type">int</span> <span class="org-variable-name">i</span> = <span class="org-highlight-numbers-number">0</span>; i &lt; size; i++) {
    <span class="org-keyword">if</span> (strcmp(map[i].key, key) == <span class="org-highlight-numbers-number">0</span>) {
      <span class="org-keyword">return</span> map[i].value;
    }
  }

  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9b9a90f" class="outline-3">
<h3 id="org9b9a90f">setHash</h3>
<div class="outline-text-3" id="text-org9b9a90f">
<p>
The second function to write is going to be called <code>setHash</code>. It will take 4 arguments:
</p>
<ul class="org-ul">
<li>The first argument is the array of the <code>Pair</code> structs.</li>
<li>The second argument will be a reference to the size of the map.</li>
<li>The third and fourth arguments are the string and integer for the key and value.</li>
</ul>

<p>
The function should add the <code>Pair</code> at the last available slot in the array, and if the array is full,
then it should dynamically reallocate the size of the array to allow more elements to be added to
it.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">int</span> <span class="org-function-name">main</span>() {
  <span class="org-type">int</span> <span class="org-variable-name">len</span> = <span class="org-highlight-numbers-number">2</span>;
  <span class="org-keyword">struct</span> <span class="org-type">Pair</span> <span class="org-variable-name">hashmap</span> = malloc(<span class="org-keyword">sizeof</span>(<span class="org-keyword">struct</span> <span class="org-type">Pair</span>) * len);
  setHash(hashmap, &amp;len, <span class="org-string">"Key 1"</span>, <span class="org-highlight-numbers-number">1</span>);
  setHash(hashmap, &amp;len, <span class="org-string">"Key 2"</span>, <span class="org-highlight-numbers-number">2</span>);
  setHash(hashmap, &amp;len, <span class="org-string">"Key 3"</span>, <span class="org-highlight-numbers-number">3</span>);
  setHash(hashmap, &amp;len, <span class="org-string">"Key 4"</span>, <span class="org-highlight-numbers-number">4</span>);

  printf(<span class="org-string">"%d"</span>, getHash(hashmap, len, <span class="org-string">"Key 3"</span>)); <span class="org-comment-delimiter">// </span><span class="org-comment">3</span>

  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
}
</pre>
</div>

<button class="toggle-spoiler">Show answer</button>
<div class="org-src-container">
<pre class="src src-c"><span class="org-type">void</span> <span class="org-function-name">setHash</span>(<span class="org-keyword">struct</span> <span class="org-type">Pair</span> *<span class="org-variable-name">map</span>, <span class="org-type">int</span> *<span class="org-variable-name">size</span>, <span class="org-type">char</span> *<span class="org-variable-name">key</span>, <span class="org-type">int</span> <span class="org-variable-name">value</span>) {
  <span class="org-type">int</span> <span class="org-variable-name">full</span> = <span class="org-constant">true</span>;
  <span class="org-type">int</span> <span class="org-variable-name">i</span>;
  <span class="org-keyword">for</span> (i = <span class="org-highlight-numbers-number">0</span>; i &lt; *size; i++) {
    <span class="org-keyword">if</span> (map[i].key == <span class="org-constant">NULL</span>) {
      full = <span class="org-constant">false</span>;
      <span class="org-keyword">break</span>;
    }
  }

  <span class="org-keyword">if</span> (full) {
    printf(<span class="org-string">"Doubling the size of the hash (%d -&gt; %d)\n"</span>, i, i * <span class="org-highlight-numbers-number">2</span>);
    *size = i * <span class="org-highlight-numbers-number">2</span>;
    map = realloc(map, <span class="org-keyword">sizeof</span>(<span class="org-keyword">struct</span> <span class="org-type">Pair</span>) * *size);
  }

  map[i].key = key;
  map[i].value = value;
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Philip Dumaresq</p>
<p class="email">Email: <a href="mailto:phdumaresq@protonmail.com">phdumaresq@protonmail.com</a></p>
<p class="date">Created: 2020-11-10 Tue 21:29</p>
</div>
</body>
</html>
