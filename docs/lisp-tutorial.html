<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-03-13 Sat 19:09 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Lisp tutorial for COMP 348</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Philip Dumaresq">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://comp-348.github.io/assets/org.css" />
<link id="theme" rel="stylesheet" type="text/css" href="assets/dark-theme.css" />
<link rel="stylesheet" type="text/css" href="assets/org.css" />
<script src="assets/toggle.js"></script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Lisp tutorial for COMP 348</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgcdfdcff">Lisp at a high level</a>
<ul>
<li><a href="#orgbf049c7">Lisp Syntax</a></li>
<li><a href="#org15c59fa">Core functions</a>
<ul>
<li><a href="#org2f72256">Destructing and rebuilding lists</a></li>
</ul>
</li>
<li><a href="#org8f0be29">Trees</a>
<ul>
<li><a href="#orgf4330a9">Binary Search:</a></li>
<li><a href="#org8980164">Tree Traversals</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="org-center">
<div class="header" id="org6ac5200">
<p>
<a href="index.html">Back</a>
</p>

</div>
</div>

<div class="toggle" id="org2718b87">

<div id="orge8bf2f8" class="figure">
<p><img src="assets/toggle-theme.png" alt="toggle-theme.png">
</p>
</div>

</div>

<div id="outline-container-orgcdfdcff" class="outline-2">
<h2 id="orgcdfdcff">Lisp at a high level</h2>
<div class="outline-text-2" id="text-orgcdfdcff">
<p>
Lisp is a high-level, dynamically typed functional programming language. Lisp first came out in
1959, around the same time as FORTRAN. Back then it was LISP, which stood for LISt Processing. As
the name indicates, Lisp is good at processing linked lists, and was created to perform tasks in
symbolic computation and artificial intelligence. Today, there are a lot of modern derivatives to
LISP, such as Common Lisp, Scheme, Racket and Clojure. In this course, we focus on Common Lisp,
which first appeared in the last 1980s as a standardization by ANSI converging features from
several prominent dialects at the time.
</p>
</div>

<div id="outline-container-orgbf049c7" class="outline-3">
<h3 id="orgbf049c7">Lisp Syntax</h3>
<div class="outline-text-3" id="text-orgbf049c7">
<p>
Lisp syntax is simple. Unlike most programming languages that are filled with different syntaxes,
keywords and operators, Lisp&rsquo;s syntax is uniform and concise. Everything that you write in Lisp will
take the form <code>(function-name arg-1 arg-2 ...)</code>. That&rsquo;s the whole syntax for the language. For
example, to define a linked list, we use the <code>list</code> function, like so: 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>list <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">4</span> <span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org15c59fa" class="outline-3">
<h3 id="org15c59fa">Core functions</h3>
<div class="outline-text-3" id="text-org15c59fa">
<p>
Would as you could guess, create a list with 5 elements. Now, as mentioned, Lisp is very good at
processing linked lists, which includes extracting data from the lists, transforming them, etc. Two
of the most important functions for this are <code>car</code> and <code>cdr</code>. The first one, <code>car</code> will return the first
element of a list, and <code>cdr</code> will return a list containing everything <i>except</i> the first element - the
tail of the list. 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defvar</span> <span class="org-variable-name">my-list</span> <span class="org-rainbow-delimiters-depth-2">(</span>list <span class="org-highlight-numbers-number">1</span> <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">4</span> <span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">(</span>car my-list<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment">; 1</span>
<span class="org-rainbow-delimiters-depth-1">(</span>cdr my-list<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment">; '(2 3 4 5)</span>
</pre>
</div>

<p>
So in this snippet we simply define a variable called <code>my-list</code> and then get the head and the tail of
that list. The 3 important function that we need to use when dealing with lists is called <code>cons</code>, and
it allows us to <code>cons</code>-truct new lists. The arguments to <code>cons</code> are going to be the first element of the
new list, and the <i>tail</i> of the new list. For example, 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span>cons <span class="org-highlight-numbers-number">1</span> <span class="org-rainbow-delimiters-depth-2">(</span>list <span class="org-highlight-numbers-number">2</span> <span class="org-highlight-numbers-number">3</span> <span class="org-highlight-numbers-number">4</span> <span class="org-highlight-numbers-number">5</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-comment">; '(1 2 3 4 5)</span>
</pre>
</div>
</div>

<div id="outline-container-org2f72256" class="outline-4">
<h4 id="org2f72256">Destructing and rebuilding lists</h4>
<div class="outline-text-4" id="text-org2f72256">
<p>
We can use these 3 functions, <code>car</code>, <code>cdr</code> and <code>cons</code> to take apart lists and put them back together
easily. Consider the following function: 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">list-identity</span> <span class="org-rainbow-delimiters-depth-2">(</span>list<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>null list<span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">()</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>cons <span class="org-rainbow-delimiters-depth-1">(</span>car list<span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">(</span>list-identity <span class="org-rainbow-delimiters-depth-2">(</span>cdr list<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
This is an <i>identity</i> function for a list, meaning it outputs whatever was input to it. It takes a
single parameter, <code>list</code>. It first checks if the list is empty using <code>(null list)</code> - in Lisp, an empty
list is considered null. If it is empty, then we return an empty list. If it is not, then we
reconstruct a new list from the components: the head of the list, and a recursive call to the
identity function with the tail of the list. This is all just an overly complicated way of showing
that we can use these 3 functions to take apart a list and rebuild it again recursively, and this is
a pattern that we see a lot of in Lisp. For example, let&rsquo;s say we wanted to add a constant number to
every value in that list:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">list-add-constant</span> <span class="org-rainbow-delimiters-depth-2">(</span>list constant<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">if</span> <span class="org-rainbow-delimiters-depth-3">(</span>null list<span class="org-rainbow-delimiters-depth-3">)</span>
      <span class="org-rainbow-delimiters-depth-3">()</span>
      <span class="org-rainbow-delimiters-depth-3">(</span>cons <span class="org-rainbow-delimiters-depth-1">(</span>+ <span class="org-rainbow-delimiters-depth-2">(</span>car list<span class="org-rainbow-delimiters-depth-2">)</span> constant<span class="org-rainbow-delimiters-depth-1">)</span> 
            <span class="org-rainbow-delimiters-depth-1">(</span>list-add-constant <span class="org-rainbow-delimiters-depth-2">(</span>cdr list<span class="org-rainbow-delimiters-depth-2">)</span> constant<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Here we have almost the same function as before: we check if the list is empty, if it is, we return
an empty list, otherwise, we construct a new list and return that. The only difference here is that
we add the constant to our number, and then pass the constant as the second argument to our
recursive call.
</p>

<p>
Like I said, this is a really common pattern in Lisp and in functional programming languages in
general, and this general pattern is going to be helpful in your assignments. 
</p>
</div>
</div>
</div>

<div id="outline-container-org8f0be29" class="outline-3">
<h3 id="org8f0be29">Trees</h3>
<div class="outline-text-3" id="text-org8f0be29">
<p>
One of the things we do a lot of in this class is talk about binary trees. Building binary trees,
searching binary trees, balancing binary trees, etc. Here&rsquo;s how we tend to represent binary trees in
this course: 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-highlight-numbers-number">7</span> <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">1</span> nil 
      <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-highlight-numbers-number">2</span> nil nil<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span> 
   <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-highlight-numbers-number">8</span> nil 
      <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-highlight-numbers-number">9</span> nil nil<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
Here, we have a single tree who&rsquo;s root node is <code>7</code>. It has a left sub-tree and a right sub-tree, both of
which have 2 nodes in their sub-trees. If we were to visualize this as a normal tree, it would look
like this:
</p>

<div class="org-src-container">
<pre class="src src-java">    7
  /   \
 1     8
/ \   / \
   2     9
  / \   / \
</pre>
</div>

<p>
Now, since creating binary trees and balancing them is sometimes on assignments, I can&rsquo;t provide
those as examples, but I can do binary-search and tree traversals. 
</p>
</div>

<div id="outline-container-orgf4330a9" class="outline-4">
<h4 id="orgf4330a9">Binary Search:</h4>
<div class="outline-text-4" id="text-orgf4330a9">
<p>
A Binary search is a divide-and-conquer algorithm, so by nature it&rsquo;s going to be recursive. The
algorithm for binary search is simple:
</p>
<ol class="org-ol">
<li>if the element we&rsquo;re searching for is equal to the head, return true.</li>
<li>if the element we&rsquo;re searching for is less than the head, binary search the left sub-tree</li>
<li>if the element we&rsquo;re searching for is greater than the head, binary search the right sub-tree</li>
<li>If the sub-tree is empty, return false.</li>
</ol>

<p>
Here&rsquo;s how we&rsquo;ll implement that in Common Lisp:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">binary-search</span> <span class="org-rainbow-delimiters-depth-2">(</span>list element<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">cond</span> 
    <span class="org-comment">; If the subtree is empty, return false</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-1">(</span>null list<span class="org-rainbow-delimiters-depth-1">)</span> nil<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-comment">; If the head is equal to what we're search for, return true</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-1">(</span>equal <span class="org-rainbow-delimiters-depth-2">(</span>car list<span class="org-rainbow-delimiters-depth-2">)</span> element<span class="org-rainbow-delimiters-depth-1">)</span> t<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-comment">; If the head is greater than the element, binary search the left subtree</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-1">(</span>&gt; <span class="org-rainbow-delimiters-depth-2">(</span>car list<span class="org-rainbow-delimiters-depth-2">)</span> element<span class="org-rainbow-delimiters-depth-1">)</span>
     <span class="org-rainbow-delimiters-depth-1">(</span>binary-search <span class="org-rainbow-delimiters-depth-2">(</span>second list<span class="org-rainbow-delimiters-depth-2">)</span> element<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-comment">; If the head is less than the element, binary search the right subtree</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-1">(</span>&lt; <span class="org-rainbow-delimiters-depth-2">(</span>car list<span class="org-rainbow-delimiters-depth-2">)</span> element<span class="org-rainbow-delimiters-depth-1">)</span>
     <span class="org-rainbow-delimiters-depth-1">(</span>binary-search <span class="org-rainbow-delimiters-depth-2">(</span>third list<span class="org-rainbow-delimiters-depth-2">)</span> element<span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
As you can see this is basically just a direct transcription of the algorithm for a binary
search. We use <code>cond</code> as our control flow here, which acts as a sequence of if/else if expressions and
just return from whichever condition is true.
</p>
</div>
</div>

<div id="outline-container-org8980164" class="outline-4">
<h4 id="org8980164">Tree Traversals</h4>
<div class="outline-text-4" id="text-org8980164">
<p>
Another common thing we want to do with trees is traverse them in various ways. With a binary-tree,
we often want to do an in-order traversal because it will visit each element in a sorted order. The
algorithm for an in-order traversal is pretty simple:
</p>
<ol class="org-ol">
<li>If the sub-tree is null, stop</li>
<li>Otherwise: 
<ol class="org-ol">
<li>perform in-order-traversal on the left sub-tree</li>
<li>Visit the root node</li>
<li>Perform in-order-traversal on the right sub-tree</li>
</ol></li>
</ol>

<div class="org-src-container">
<pre class="src src-lisp"><span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">defun</span> <span class="org-function-name">in-order-traversal</span> <span class="org-rainbow-delimiters-depth-2">(</span>tree<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-rainbow-delimiters-depth-2">(</span><span class="org-keyword">cond</span>
    <span class="org-rainbow-delimiters-depth-3">(</span><span class="org-rainbow-delimiters-depth-1">(</span>null tree<span class="org-rainbow-delimiters-depth-1">)</span> nil<span class="org-rainbow-delimiters-depth-3">)</span>
    <span class="org-rainbow-delimiters-depth-3">(</span>t <span class="org-rainbow-delimiters-depth-1">(</span>in-order-traversal <span class="org-rainbow-delimiters-depth-2">(</span>second tree<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
       <span class="org-rainbow-delimiters-depth-1">(</span>print <span class="org-rainbow-delimiters-depth-2">(</span>first tree<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
       <span class="org-rainbow-delimiters-depth-1">(</span>in-order-traversal <span class="org-rainbow-delimiters-depth-2">(</span>third tree<span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span><span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
So if we run this with the same tree as above, it&rsquo;ll print 1, 2, 7, 8, 9. 
</p>

<p>
Now, from here there&rsquo;s a lot of basic changes that we could make to make this function do some
other stuff, like instead of just printing every node, we could pass a lambda function that we call
instead of <code>print</code>. Or we could append the 3 things together to build a sorted list, or all sorts of
other things. 
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Philip Dumaresq</p>
<p class="email">Email: <a href="mailto:phdumaresq@protonmail.com">phdumaresq@protonmail.com</a></p>
<p class="date">Created: 2021-03-13 Sat 19:09</p>
</div>
</body>
</html>
